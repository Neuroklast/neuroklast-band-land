import { kv } from '@vercel/kv'
import { applyRateLimit } from './_ratelimit.js'

/**
 * Server-side image proxy that fetches remote images, caches them in Vercel KV,
 * and returns the binary data. Handles Google Drive URLs and other CORS-restricted
 * sources. The KV cache survives deployments.
 *
 * GET /api/image-proxy?url=<encoded-url>
 */

const MAX_CACHEABLE_IMAGE_SIZE = 4 * 1024 * 1024 // 4 MB — larger images are served but not cached
const CACHE_TTL_SECONDS = 60 * 60 * 24 * 30 // 30 days

/** Block requests to private/internal networks to prevent SSRF */
const BLOCKED_HOST_PATTERNS = [
  /^localhost$/i,
  /^127\./,
  /^10\./,
  /^172\.(1[6-9]|2\d|3[01])\./,
  /^192\.168\./,
  /^0\./,
  /^169\.254\./,
  /^\[::1\]/,
  /^\[::ffff:/i,
  /^\[fe80:/i,
  /^\[fc/i,
  /^\[fd/i,
  /^metadata\.google\.internal$/i,
  /^0x[0-9a-f]+$/i,
  /^0[0-7]+\./,
]

/** Allowed URL protocols */
const ALLOWED_PROTOCOLS = new Set(['http:', 'https:'])

function isBlockedHost(hostname) {
  if (BLOCKED_HOST_PATTERNS.some(p => p.test(hostname))) return true
  // Block numeric-only hostnames (decimal IP like 2130706433 = 127.0.0.1)
  if (/^\d+$/.test(hostname)) return true
  // Block hostnames without a dot (e.g. "internal", "localhost")
  if (!hostname.includes('.') && !hostname.startsWith('[')) return true
  return false
}

function toDirectUrl(url) {
  const driveFile = url.match(/drive\.google\.com\/file\/d\/([^/?#]+)/)
  if (driveFile) return `https://drive.google.com/uc?export=view&id=${driveFile[1]}`
  const driveOpen = url.match(/drive\.google\.com\/open\?id=([^&#]+)/)
  if (driveOpen) return `https://drive.google.com/uc?export=view&id=${driveOpen[1]}`
  // Handle all uc URLs (both export=view and export=download) by extracting the ID
  const driveUc = url.match(/drive\.google\.com\/uc\?[^#]*?id=([^&#]+)/)
  if (driveUc) return `https://drive.google.com/uc?export=view&id=${driveUc[1]}`
  // Handle lh3 CDN URLs — convert back to reliable export URL
  const lh3Match = url.match(/lh3\.googleusercontent\.com\/d\/([^/?#]+)/)
  if (lh3Match) return `https://drive.google.com/uc?export=view&id=${lh3Match[1]}`
  // Handle wsrv.nl-wrapped lh3 URLs — extract the file ID and convert
  const wsrvLh3Match = url.match(/wsrv\.nl\/\?url=https?:\/\/lh3\.googleusercontent\.com\/d\/([^/?#&]+)/)
  if (wsrvLh3Match) return `https://drive.google.com/uc?export=view&id=${wsrvLh3Match[1]}`
  return url
}

function cacheKey(url) {
  return `img-cache:${url}`
}

export default async function handler(req, res) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' })
  }

  // Rate limiting — blocks image proxy abuse (GDPR-compliant, IP is hashed)
  const allowed = await applyRateLimit(req, res)
  if (!allowed) return

  const { url } = req.query
  if (!url) {
    return res.status(400).json({ error: 'url parameter is required' })
  }

  // Validate and block dangerous URLs
  let parsed
  try {
    parsed = new URL(url)
  } catch {
    return res.status(400).json({ error: 'Invalid URL' })
  }
  // Only allow http(s) protocols (blocks file://, data://, javascript://, etc.)
  if (!ALLOWED_PROTOCOLS.has(parsed.protocol)) {
    return res.status(400).json({ error: 'Invalid URL protocol' })
  }
  // Block requests to private/internal networks (SSRF prevention)
  if (isBlockedHost(parsed.hostname)) {
    return res.status(400).json({ error: 'Blocked host' })
  }

  const directUrl = toDirectUrl(url)

  // Re-validate the transformed URL as well
  try {
    const parsedDirect = new URL(directUrl)
    if (!ALLOWED_PROTOCOLS.has(parsedDirect.protocol) || isBlockedHost(parsedDirect.hostname)) {
      return res.status(400).json({ error: 'Blocked host' })
    }
  } catch {
    return res.status(400).json({ error: 'Invalid URL' })
  }

  const key = cacheKey(directUrl)

  try {
    // Check KV cache first
    const cached = await kv.get(key)
    if (cached && cached.data && cached.contentType) {
      const buf = Buffer.from(cached.data, 'base64')
      res.setHeader('Content-Type', cached.contentType)
      res.setHeader('Cache-Control', 'public, max-age=86400, s-maxage=2592000')
      res.setHeader('Access-Control-Allow-Origin', '*')
      return res.status(200).send(buf)
    }
  } catch (e) {
    console.warn('KV cache read failed:', e)
  }

  try {
    const response = await fetch(directUrl, {
      headers: { 'User-Agent': 'Mozilla/5.0 (compatible; NeuroklastImageProxy/1.0)' },
      redirect: 'follow',
    })

    // Validate the final URL after redirects to prevent SSRF via redirect
    if (response.url) {
      try {
        const finalUrl = new URL(response.url)
        if (!ALLOWED_PROTOCOLS.has(finalUrl.protocol) || isBlockedHost(finalUrl.hostname)) {
          return res.status(400).json({ error: 'Blocked redirect target' })
        }
      } catch {
        return res.status(400).json({ error: 'Invalid redirect URL' })
      }
    }

    if (!response.ok) {
      return res.status(response.status).json({ error: `Upstream returned ${response.status}` })
    }

    const contentType = response.headers.get('content-type') || 'image/jpeg'
    // Only allow image content types through the image proxy.
    // Reject text/html, application/javascript, etc. to prevent XSS.
    if (!contentType.startsWith('image/')) {
      return res.status(400).json({ error: 'Unsupported content type' })
    }

    const arrayBuf = await response.arrayBuffer()
    if (arrayBuf.byteLength > MAX_CACHEABLE_IMAGE_SIZE) {
      // Serve but don't cache very large images
      res.setHeader('Content-Type', contentType)
      res.setHeader('Cache-Control', 'public, max-age=86400')
      res.setHeader('Access-Control-Allow-Origin', '*')
      return res.status(200).send(Buffer.from(arrayBuf))
    }

    const base64 = Buffer.from(arrayBuf).toString('base64')

    // Cache in KV (fire-and-forget)
    kv.set(key, { data: base64, contentType }, { ex: CACHE_TTL_SECONDS }).catch((e) => {
      console.warn('KV cache write failed:', e)
    })

    res.setHeader('Content-Type', contentType)
    res.setHeader('Cache-Control', 'public, max-age=86400, s-maxage=2592000')
    res.setHeader('Access-Control-Allow-Origin', '*')
    return res.status(200).send(Buffer.from(arrayBuf))
  } catch (error) {
    console.error('Image proxy error:', error)
    return res.status(502).json({ error: 'Failed to fetch image' })
  }
}
